<script Modulo
    src="/js/Modulo.js"
    -src="/libraries/all.html" 
></script>

<!-- Note: _part1.html is intententional, to un-collapse the top thing -->
<mws-Page
    docbarselected="tutorial_part1.html"
    pagetitle="Part 2 - Tutorial"
    navbar="docs">

<h1>The Modulo Tutorial: Part 2</h1>

<p>In Part 2 of this tutorial, we'll explore three more features: Customizing
with Props, substituting with Template variables, and finally building your
finished project into a single faster-loading file. Prerequisites: HTML, CSS,
and Part 1.</p>


<mws-Section name="props">1. Props</mws-Section>

<p>In the previous section, we were mostly concerned with <em>defining
components</em>. Recall that components are defined once, but can be used many
times.  The purpose of <em>Props</em> is to allow more flexibility in that
second step: <em>Props</em> CPart defines the <em>properties</em> that can be
customized about a component each time it is reused.  We already know that
"slots" can be used to customize components with extra content, which is a good
start. However, what if we wanted even more options for users to customize the
components, such as by using HTML properties?  Thus, to start our discussion of
<em>Props</em> we'll first get more practice reusing components.</p>

<h3>Other people's components</h3>

<p>Before we learn how to use the <em>Props</em> CPart itself, let's first get
acquainted with a concept we haven't done before: Reusing components that were
coded by someone else! In a realistic scenario of an organization building a
web app, it's likely that most of the components you will be using won't
actually be written by you personally, but instead by someone else on some sort
of internal "component library" team.  Similarly, even if working by yourself,
you'll need to learn how to component libraries written by others so you can
use components already defined for you to accomplish common tasks. Don't
reinvent the wheel!</p>

<p>In this next activity, we'll practice reusing components.</p>

<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Context: The <code>&lt;x-ExampleBtn&gt;</code> button component has
    already been defined for you. It was defined to accept two so-called
    <em>"props"</em>: <code>label</code>, and <code>shape</code>. We'll cover
    how it was defined to use a <em>Props</em> CPart later on. For now, we'll
    practice only with using the <code>x-ExampleBtn</code>.</p>

    <ol>
        <li>Examine the code below. Examine the preview on the right. Do you
        see how the code in turn uses the <code>x-ExampleBtn</code> in two
        locations, with a different shape and label each? We can call each of
        these a <em>component instance</em>. Each component instance can
        receive different or customized <em>props</em> attributes.</li>

        <li>Note the <code>label="..."</code> prop attribute that is on each
        <code>x-ExampleBtn</code>. Test it out by editing the contents of this
        attribute on one or both of the buttons and click RUN to see the result
        on the right.</li>

        <li>Note the <code>shape="..."</code> prop that is on each button. It's
        impossible to have known this without reading the CSS of
        <code>x-ExampleBtn</code>, but it accepts either "square" or "round".
        Try changing one to the other and see the results.</li>
    </ol>

    <mws-Demo
        demotype="minipreview"
        fromlibrary="Tutorial_P2"
    ></mws-Demo>

    <p><strong>Comprehension Challenge 1:</strong> Based on the patterns you see
    here, add a third button to this example that is round and contains the
    word "Hello".</p>
    <p><strong>Comprehension Challenge 2:</strong> See if you can think up what
    props might be attached to different types of widgets, e.g. a "modal
    pop-up" widget might specify the title, or an Open Street Map widget might
    specify latitude and longitude for the map being displayed. What would a
    text input need? What about a tabbed navigation interface? How about a
    component that shows a chess board with pieces in a specified setup?</p>
</section>


<blockquote> <p><strong>Why use Props?</strong>
Components are "write once, use everywhere". That is to say, you only need to
define a component once to use it throughout your pages. The advantages of
"write once, use everywhere" are clear: By writing "DRY" (non-repetitive)
code, you can make changes to the single component definition and see those
changes take effect wherever that component might be used.
However, sometimes you want each instance of a component to have different
content or modified behavior. This is where <em>Props</em> come into play: They
allow you to customize differences in content or behavior between multiple uses
of the same component.</p>
</blockquote>


<h3>Defining props</h3>

<p>Let's "peel back the layers" and examine out how this ExampleBtn was
written.</p>

<p>In order for a component to be able to "receive" props when it is reused, we
must define a <em>Props</em> CPart, which is conventionally placed as the first
thing in a component definition. <em>Props</em> CParts are defined somewhat like
previous CParts, except they have no contents and are just an opening tag with
attributes, followed by a closing tag. A <em>Props</em> CPart might look like
this:</p>

<pre>&lt;Props name device frequency&gt;&lt;/Props&gt;</pre>

<p>The recommended style for Modulo code is to add a newline after each prop
name for easier reading. HTML syntax doesn't care either way, so the above
might be improved for readability if it were written as follows:</p>

<pre>
&lt;Props
    name
    device
    frequency
&gt;&lt;/Props&gt;
</pre>


<p>Once you have defined which props you expect a component to receive by using
the <em>Props</em> CPart, you can then reference the values of those props
elsewhere within the component: Either in the <em>Template</em> CPart (what
we'll cover next), or in the <em>Script</em> CPart (covered later).</p>


<mws-Section name="templating">2. Templating</mws-Section>

<blockquote> <p><strong>Can I use props in CSS?</strong>

<p>No. Note that the <em>Style</em> CPart intentionally does not support
template substitution, or any such "live" modification whatsoever. If you want
to directly insert props as CSS values, this should be done in the template by
using an inline <code>style=</code> attribute. For more complicated CSS
transformations, consider setting CSS variables on the <code>style=</code>
attribute that are then used by the <em>Style</em> CPart, by using the
<code>var()</code> CSS function.</p>
</blockquote>

<p>Our discussion of props gives us a chance to explore the <em>Template</em>
CPart a little bit deeper. Previously, we have only used a <em>Template</em>
CPart to display static, unchanging HTML. That's quite limiting. The typical
purpose of "templating" or "a templating language" is to allow customization,
substitution, and transformation of HTML content.  Templating isn't unique to
web development: If you've used template files with word processors such
Microsoft Word, or email templates within marketing or sales software, you'll
know that with templating you can include placeholders where we want to insert
data or values, in order to personalize each instance.</p>



<h4>Using props within a template</h4>

<p>Within a <em>Template</em> CPart, we can insert data or values using a
special "placeholder" syntax that is as follows:
<code>{{&nbsp;myVariableName&nbsp;}}</code>.
We can also use a dot (".") in this syntax to access properties.
Thus, you will see this placeholder syntax more often used like this:
<code>{{ props.device }}</code>. So, combining this information with the 3
props that we have above, we can create a template that has 3 placeholders that
get filled in with specific data when the component gets reused. Examine the
below code and try to guess at what it might do:</p>

<pre>
&lt;Template&gt;
    Hi {{ props.name }}, your {{ props.device }} is at {{ props.frequency }}hz.
&lt;/Template&gt;
</pre>

<p>In this case, if we were to use our component with the attributes
<code>name="Tux"</code>, <code>device="Radio"</code> and
<code>frequency="2600"</code>, then the following text would be rendered:
<code>Hi Tux, your Radio is at 2600hz.</code></p>


<p>The "Modulo templating language" was modeled after Django, Jinja2, or
Liquid, and thus is quite powerful, being capable of much than the simple
substitutions we're learning here. We'll learn more features later.</p>


<h4>Combining props with template HTML</h4>

<p>In the previous example, we showed how text can be rendered using
substitutions. Next let's see how such substitutions can be used to generate
more complex HTML code.</p>

<p>Examine the following component definition. This component definition is the
same definition for the <code>x-ExampleBtn</code> that was referenced in the
previous challenge (with the exception of some CSS being omitted for
simplicity):</p>

<mws-Demo
text='
<Component name="ExampleBtn">

    <Props
        label
        shape
    ></Props>

    <Template>
        <button class="my-btn  my-btn__{{ props.shape }}">
            {{ props.label }}
        </button>
    </Template>

    <Style>
        .my-btn__square {
            border-radius: 1px 8px 1px 8px;
        }
        .my-btn__round {
            border-radius: 150px;
        }
        /* ...snip... */
    </Style>

</Component>
'
></mws-Demo>


<p>At this point, we can finally begin to understand the
<code>&lt;x-ExampleBtn&gt;</code> component that we were using previously. In
this case, the value of the <code>label="Example Button"</code> prop gets
inserted as the text content of the button element, and the
<code>shape="round"</code> prop value gets inserted in the <code>class=</code>
attribute of the button element.  Thus, if the shape prop receives the value of
"round", the button gets the CSS class of <code>.my-btn__round</code>, and
similarly if it received the value of "square", it'd get the class
<code>.my-btn__square</code>. These CSS classes, as you may have guessed, are
what controls the look of the button, either giving it rounded edges or a more
rectangular, towering look.</p>


<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Okay, let's take this new concept and apply it to our previous
    HelloWorld component. Go back to the project you were working on
    previously, and follow these steps to practice adding props to your
    component:</p>
    <ol>
        <li>Examine your <code>HelloWorld</code> component definition. Near the
        top, just below the "&lt;component..." opening tag, add a
        <em>Props</em> CPart, just like the examples before.</li>
        <li>Experiment with specifying props. For example, to keep building
        this tutorial app, give it the props of <code>goal</code> and
        <code>amount</code>.</li>

        <li>If done correctly, your component definition will start something
        like this:
<mws-Demo
text='
<Component name="HelloWorld">
    <Props
        goal
        amount
    ></Props>
    <!-- ... snip ... -->
</Component>
'></mws-Demo>
        </li>

        <li>Update the template to now use these props somewhere. For the
        tutorial example, we'll be building a little "clicker" that will count
        up to a number (the "goal") by an increment amount (the "amount"). So,
        for now, let's just display the goal prop and amount prop:</li>
<mws-Demo
text='
<Template>
    Hello <strong><slot></slot></strong> World!
    <p>Goal: {{ props.goal }}</p>
    <p>Amount: {{ props.amount }}</p>
</Template>
'></mws-Demo>

        <li>Refresh the web browser to view the results. Assuming you still
        have the component displaying somewhere on your page, if done
        correctly, you will see your component update to reflect the changes
        you made to your template, possibly something  like "Goal: "
        and "Amount: ".</li>

        <li><strong>Comprehension question: Why doesn't it show any text after
        "Goal:" and "Amount:"?</strong></li>

        <li>Answer: If you are seeing blanks, it's probably because you
        are not passing in the Props that are required.</li>

        <li>To fix this, we need to specify the props in the location where we
        are <em>reusing</em> or actually displaying the component on the page.
        This is done by adding attributes with the names "goal" and "amount" to
        the component tag instances.</li>

        <li>If you have made a lot of changes since <em>Part 1</em> of this
        tutorial or did not follow the naming suggestions, your code may end
        looking different than this. However, if that's not the case, your code
        might end up looking like this:
<mws-Demo
text='
<div>
    <x-HelloWorld
        goal="10"
        amount="2"
    >Learning</x-HelloWorld>
    <p>In a P tag:
        <x-HelloWorld
            goal="5"
            amount="1000"
        >Small</x-HelloWorld>
    </p>
</div>
'></mws-Demo>

        </li>
    </ol>

    <p><strong>Bonus Challenge:</strong> Read ahead about <em>template
    filters</em>, and try using those here.</p>
</section>


<h3>Template filters</h3>

<p>The Modulo templating language has two more big features: <em>filters</em>
(for formatting values), and <em>template-tags</em> (for control-flow). We'll
briefly introduce <em>filters</em> now, but for a more thorough introduction to
the Modulo templating language, you should <a href="/docs/templating.html">read
the Templating section</a>.</p>

<p>Template <em>filters</em> format or otherwise transform template variables.
The template filter syntax consists of taking a template variable and adding a
vertical bar followed the name of a filter (e.g.
<code>varName|filterName</code>). The following example will transform the text
contained in the <code>props.name</code> template variable to make it all
uppercase:</p>

<pre>Hello {{ props.name|upper }}</pre>

<p>Some filters can also take extra modifiers or options. This is called the
template filter <em>argument</em>. Do you recall how our previous ExampleBtn
component only supported either "round" or "square" as CSS classes? In this
next example, we are going to use the <code>|allow</code> template filter to
ensure that only "round" or "square" are permitted: </p>

<pre>&lt;button class="my-btn my-btn__{{ props.shape|allow:"round,square" }}"&gt;
    (... snip ...)
&lt;/button&gt;</pre>

<p>Note how the argument is separated from the filter with a colon: The general
syntax is <code>varName|filterName:"argument"</code>. Thus, the
<code>|allow:"round,square"</code> filter instructs Modulo to <em>only</em>
output the property of <code>props.shape</code> if it exactly matches the text
"round" or "square".</p>

<p>You can do more than this with filters: You can string together the dozens
of available filters for more powerful combinations, and by using JavaScript
script tags (covered in Part 3) you can easily author your own.
The full <a href="/docs/templating-reference.html">Templating Reference</a> has
examples of all filters available.</p>


<h3>Template tags</h3>

<p>In addition to filters, the Modulo templating language also support powerful
"template tags", which allow for more complicated custom behavior. This
includes the "if" template-tag, which allows for conditional rendering (e.g.
"only show the submit button if a form is filled correctly"), and the "for"
template-tag, which allows for HTML to be repeated for each item of some given
data (e.g.  "every blog post get's it's own <code>&lt;li&gt;</code> element").
The full <a href="/docs/templating-reference.html">Templating Reference</a> has
examples of the different template tags available.</p>



<!--
<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Edit the component definition on the left, and click RUN to see the
    results on the right!</p>

    <ol>
        <li>Practice modifying the <strong>Template</strong> CPart
        (<code>&lt;Template&gt;</code>) to see how that affects the
        output</li>
        <li>Practice modifying the <strong>Style</strong> CPart
        (<code>&lt;Style&gt;</code>) to add or modify CSS</li>
        <li>Practice incorporating these CParts into your own components on
        a real page by copying the code here and pasting it within your
        component definition (that is, the one that you created in the
        previous part of this tutorial)</p>
    </ol>
    <mws-Demo
        demotype="minipreview"
        fromlibrary="Tutorial_P2_filters_demo"
    ></mws-Demo>
</section>
-->



<mws-Section name="build">3. Build</mws-Section>


<blockquote> <p><strong>Why build?</strong>
Let's start with a "thought experiment", where we fast forward into the
future. Imagine that as you create more and more components, you begin
splitting them up into more component libraries. Also, as mentioned previously,
perhaps you find some nice component libraries that others have made that you
want to use in your project. In the end, you might find yourself with dozens of
HTML files being loaded, scattered in different directories.
</p>

<p>In this situation you will have too many <code>&lt;Library&gt;</code> tags,
meaning your page may take a long time to start-up.  As it's downloading all
the different files, the browser will be showing the ugly, unformatted text in
the mean-time.  On slow connections, this could be end up being a frustrating
experience for users. This is why building to one file is useful.</p>
</blockquote>

<p>We've got one more topic for <em>Part 2</em> of the Modulo tutorial:
How to keep your project manageable and loading fast as <em>Component</em>
definitions grow and larger.</p>

<h3>Library tags with <code>-src=</code></h3>

<p>"Library" tags look like the following:</p>

<pre>
&lt;Library
    -src="./libraries/my-stuff.html"
    namespace="coolstuff"&gt;
&lt;/Library&gt;
</pre>

<p>Let's break this down:</p>
<ul>

    <li>
        <code>-src="./libraries/my-stuff.html"</code>
        <p>The <code>-src</code> attribute specifies the source of the
        component library file. This file can be anywhere that is
        accessible to your web-browser or web-server. Ideally, it should be
        in the same place as your CSS and static media files, such as a
        <code>static/</code> directory, or whatever the equivalent is for
        your set-up.</p>
        <p>The component library itself (<code>my-stuff.html</code> in this
        example) should consist of an HTML file filled with
        <code>&lt;Component&gt;</code> definitions.</p>
    </li>

    <li>

        <blockquote>
        <p><strong>Why use namespaces?</strong>
        Namespaces allow different component library files to have
        conflicting component names. This is especially useful when using
        third-party component libraries or while working in a big team:
        That way, if both you and another developer define a component with
        some common name (eg <code>name="Button"</code>), there won't be a
        conflict as long as you load each into different namespaces.</p>
        </blockquote>

        <code>namespace="coolstuff"</code>
        <p>The <code>namespace</code> attribute specifies the
        <em>namespace prefix</em>, which is combined with a dash and the
        component name in order to create the component's <em>full
        name</em>. </p>
        <p><strong>Example:</strong> If <code>my-stuff.html</code> has a component
        defined like <code>&lt;Component name="MyThing"&gt;</code>
        imported with <code>namespace="coolstuff"</code>, then the
        resulting full name would be <code>coolstuff-MyThing</code>, and
        we'd use the component like<br />
        <code>&lt;coolstuff-MyThing&gt;&lt;/coolstuff-MyThing&gt;</code>.</p>
    </li>


    <li><strong>Where to put it:</strong> The Modulo tag can go anywhere in
    your HTML. For neatness, consider putting them either within the
    <code>&lt;head&gt;</code> tag, or near the <code>&lt;/body&gt;</code>
    closing tag. After being built, it won't matter: The JS script tag will be
    put before the <code>&lt;/body&gt;</code>.</li>
</ul>

<p>However, there is a downside to splitting up your files: Each new file you
create will require an additional request to load it. This means that each
additional individual file you include in a page will cause the page to take a
little longer to loader. So, if <code>-src=</code> causes it to load slower, how
can we stay neat during development, but still have a fast site? This is where
"building" comes into play.</p>

<h3>Modulo build: Packing it all up</h3>

<p>"Building" is a feature of Modulo where it will pack up all the components
you have loaded on a particular page into a single JS file. This single JS
file, called a <em>build</em>, will contain all the code from all your
components (including CParts that were split off using <code>-src=</code>).
Once the "build" file is included using a
<code>&lt;script&nbsp;src="..."&gt;</code> tag, then all subsequent
<code>&lt;Library&gt;</code> tags on that page will not actually fetch the
original HTML file that they are pointed to, but instead load the "built"
version from the JS file. It will also pre-compile the JavaScript, removing the
need for "eval". This causes the page to load very quickly, even faster than
during development.  Generally, developers create builds before "launching"
their site to "production" (e.g.  publishing their site for the world to see),
since it results in the fastest possible loading time. Note that you should
only attempt to edit your original, source files: Builds are only for releasing
or publishing, but not for editing.</p>

<p>Even with built JavaScript code, you might notice that there is a
"flicker" effect, where the page remains unstructured and unstyled until all
your components finish rendering their <em>Templates</em>. Depending on how
complicated your page is, this could be brief and forgivable, or could take a
while and create a bad user experience.</p>

<p>To prevent the flicker, whenever you <code>build</code> or <code>bundle</code>
Modulo will also prerender the HTML as well, and output a brand new HTML file
that can be published instead of your original one. A "prerendered HTML" file
is a special, processed HTML file which basically "freezes" the result of
loading the page for the first time. You can use this messy, processed HTML
file as the replacement page when launching, as it will already have JavaScript
and CSS tags included for your build or bundle!</p>

<p>To build a project, we will need to run a <em>Modulo Command Menu</em>.
The <em>console</em> is a feature of all web browsers. As a web developer you
likely have used it: It's a panel, hidden by default, where JS, CSS, and other
such error messages are displayed. While most JS frameworks require NPM-based
tools to build, Modulo can be built right from your browser's console, simply
clicking on the <code>build</code> or <code>bundle</code> commands in the
<code>COMMAND</code> menu, that is visible in your browser developer tools
console.</p>


<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <ol>
        <li>Open up your HTML file in your browser (e.g. Firefox or
        Chrome/Chromium). Do not open your component library HTML files: Be
        sure to open the file that <em>is doing the importing</em> and
        <em>using the components</em>, not the file(s) that contain the
        component definitions themselves.</li>

        <li>Bring up the console: Press <code>Control+Shift+J</code> (Linux,
        Windows) or <code>Command+Option+J</code> (macOS) on your keyboard to
        open the Console. Alternatively, you can right-click with your mouse
        and select "Inspect", and then go to the <em>Console</em> tab.</li>

        <li><em>Optional:</em> Within the newly opened developer tools,
        navigate for a moment to the "Network" tab.  Force refresh your
        browser. You should see a list of "requests" being sent, including one
        for each component library that needs loading.  For example, if we
        named our component library "./libraries/my-component-lib.html", we'll
        see an additional request for this HTML file. If we had further split
        our files using "-src=", we'll see even more requests.</li>

        <li>Do you see a Modulo logo (<code>%</code>), with the word
        <code>COMMANDS</code>? Click on <code>COMMANDS</code>, and possibly one
        more time (on Firefox), and you should see a command menu, containing
        commands like <code>build</code>, <code>bundle</code>, and <code>test</code>.
        To build, simply click the "<code>build</code>" command.

            <p>Note: Look in the upper-right hand of your browser. You might see a
            warning, prompting you about "Allowing multiple downloads". You should
            allow it, otherwise it will block the generated files from being
            downloaded. If you see no warnings about this, then just continue to
            the next step.</p>
        </li>

        <li>Your browser should reload, and then offer to download an HTML,
        CSS, and JS file, or perhaps offer a way to save them.  These are the
        "build" files, and contain the contents of all libraries that were
        loaded on this page, with underlying JavaScript pre-compiled for speed
        and security. Save them all together in some spot.</li>

        <li>The HTML "build" is a copy of the HTML page you were working on,
        with two important differences:
            <li>Difference #1: It's been modified to include the built
            versions of the CSS and JS: A link tag to include the CSS file is
            inserted before the <code>&lt;/head&gt;</code>, and
            a script tag inserted before the <code>&lt;/body&gt;</code> tag to
            include the JS file.</li>
            <li>Difference #2: It contains the page's <em>current</em> state,
            e.g., the result of an initial render. This means that when that
            HTML page is loaded, it will be "prerendered", and thus appear to
            load much faster, and components will render correctly, even before
            the JavaScript finishes loading.</li>
        </li>

        <li>Now, open up your "build" file. If all went well, it should look
        and behave exactly as before, except load much faster.</li>

        <p><em>Tip:</em> If all went well after building, you should see a link
        to the command you just ran. Clicking on the link will refresh the
        page, causing it to build again. You can also just hit refresh (Ctrl+R
        or Command+R) to rebuild. Consider keeping this window open, or as
        another tab, and resuming work in another window. Then, to rebuild,
        simply switch back to this window, and either click the button or hit
        refresh!</p>

        <li><em>Optional:</em> Time to validate that the "build" worked!
        Navigate to the "Network" tab of your Development Console. Force
        refresh your browser. You should now see no more extra "requests" being
        sent for each HTML component library that needs to be loaded. Instead,
        just the JS "build" file "preloads" all the individual files in one
        go.</li>
    </ol>


    <p><strong>Important: Don't edit your builds!</strong> Built files are
    disposable. Don't edit the HTML, JS, or CSS files produced. Instead,
    continue working on your original "source" files, and then build again. The
    purpose of these new "built" files is to only share them when you are done
    with your website. These should only be used when "launching" your site.
    Your development should continue on the "source" files.</p>
    <p>This can easily trip up beginners: The build "freezes" the component
    library in time, and you'll have to run build again if you change anything.
    A common mistake is forgetting that you are editing the original
    <code>.html</code> file while using the built <code>.js</code> version,
    causing much confusion as to why your changes don't take effect!</p>

</section>


<h3>Modulo bundle: Packing it all up in one go</h3>


<blockquote>
<p><strong>Build vs bundle?</strong> Not sure which to use? Typically, "bundle"
is the fastest and easiest. However, there are purposes for both.</p>

<p>"Build" builds all loaded Components into JS and CSS files, pre-compiling
Templates and JavaScript to avoid "eval". These JS and CSS files do not include
Modulo, or any other JS or CSS. This is often good if you intend then to
further pack these files using other tools, or if you want to more flexibly
include different content between pages. Unlike bundles, builds will include
the source code in the JS file, possibly resulting in a slightly larger
file.</p>

<p>"Bundle" does all of the above, but instead of including files verbatim, it
will omit the source code and include a "config bundle" that gets stored in
literal data-structure in the JavaScript file. This can reduce total file size
and make everything load faster.</p>

<p>Bundle also combines all the JS and CSS, even files unrelated to Modulo.
It's useful if if you want a "drop-in" portable set of JS and CSS files to use
elsewhere with optimal speed. For example, you could have a "component
development" HTML file which you run "bundle" on, and then you use that build
throughout the rest of your site, even on pages which previously didn't use
Modulo.</p>
</blockquote>


<p>So, we've learned how to "build" our components into a single JS file, which
prevents extra requests. However, it doesn't solve the issue of having to do a
separate request for the Modulo source code, or the possibly verbose or messy
"boilerplate" which you need to copy between every HTML file. Furthermore, if
you intend to incorporate more JS files or CSS libraries, we could end up
making many requests again. This is where Modulo's "bundle" command comes into
play.</p>

<p>Modulo also has a "bundle" command. A "bundle" does everything a "build"
does, but even more: A "bundle" will include the Modulo.js source code as well,
along with any other JS or CSS files that are loaded. This will result in a
much simpler built HTML file, clearing ALL the script tags, "Library" tags, and so
on, and leaving only one single CSS file, one single JS file, and the
pre-rendered HTML.</p>

<h3>Using bundles elsewhere</h3>

<p>This "bundle" can then be used on any page to immediately activate
your components, using the same namespaces that you activated in the page that
you built from, without any need of explicitly loading the library. In other
words, the bundle command will "freeze" all the JS and CSS on the current page
into single JS and CSS file that can be used anywhere, including in non-Modulo
projects.</p>

<p>See below for an example of including a bundle in another page:</p>

<mws-Demo
text='
<!-- Include the output of the bundle command: -->
<link rel="stylesheet" href="./modulo-bundle.(some hash goes here).css" />
<script src="./modulo-bundle.(some hash goes here).js"></script>

<!-- Now, the components we define can be used just like before: -->
<x-HelloWorld goal="10" amount="2" ></x-HelloWorld>
'></mws-Demo>

<p>Note that once you've bundled your scripts, there is no need for using
<code>&lt;script Modulo ... &gt;</code> or <code>&lt;Library&gt;</code> tags.
Everything is already "bundled" and automatically activating in that
one single JS script.</p>


<h3>Part 2: Summary</h3>

<p>In this tutorial, we learned how to specify props as attributes to use and
configure other people's components and how to define the <em>Props</em> CPart
which allows our components to be configured via attributes when used. We
learned how to use Modulo's templating language to include variables and format
values using filters, and finally wrapped up with trying Modulo's self-building
feature.</p>


<h4>Key terms</h4>

<ul>
<li> <strong>Props</strong> - A CPart used to specify attributes, that the user
of a component can use to configure that Component</li>

<li><strong>Template variable</strong> and <strong>template filter</strong> -
Modulo's Templating language can include template variables (e.g.  <code>{{
props.name }}</code>) mixed in with the HTML, and possibly modified or
reformatted by attaching template filters (e.g. <code>{{ props.name|upper
}}</code>)</li>

<li><strong>build</strong> - Combining all your JS and CSS together into a
single file that loads faster, and prerender the HTML so there's no flicker.

<li><strong>bundle</strong> - Do a build, but also auto-activate the components
and include any extra, non-Modulo JS or CSS files as well.</li>

</ul>


<h4>Next step</h4>

<p>At this point, you've learned enough to be dangerous! If you intend to
mostly use Modulo as a template developer, refactoring HTML into template-based
web components, then you are all ready to get going.  Feel free to try using
Modulo to refactor your HTML, be sure to test on all target browsers (Modulo is
still under development, after all), and then finally use the self-packing
feature to include a JS file that loads quickly. To improve your template
development skills, you might want to skip learning about Script CParts, and
instead read deeper on the capabilities of the <a
href="/docs/templating.html">Modulo templating language</a>, which you can use
to build more complicated re-usable HTML and CSS.</p>

<p>However, if you are at least a little familiar with JavaScript and/or
React-style SPA frameworks, and want to learn how to make more complex,
interactive applications using State and Script, then get going with <a
href="/docs/tutorial_part3.html">Part 3: State, Directives, and
Scripting</a></p>

<p><a class="m-Btn" href="/docs/tutorial_part3.html">
    Part 3: State, Directives, and Scripting &#187;
</a></p>

</mws-Page>





<!--
        <li>Now, let's practice updating our HTML file to use the build.  The
        end result might look something like this:
<mws-Demo
text='
<! - - Add in built JS file (Remember: Ensure the path is correct!) - - >
<link rel="stylesheet" href="./modulo-build.(some hash goes here).css" />
<script src="https://modulojs.org/js/Modulo.js"></script>
<script src="./modulo-build.(some hash goes here).js"></script>

<! - - KEEP your old loading code: - - >
<Modulo>
    <Library src="./components/my-component-lib.html" namespace="lib" ></Library>
</Modulo>

<! - - Make sure we defineAll (but only AFTER the script tags) - - >
<script>Modulo.defineAll();</script>

<! - - Now, the components we define can be used just like before: - - >
<div>
    <x-HelloWorld goal="10" amount="2">Learning</x-HelloWorld>
    <p>In a P tag: <x-HelloWorld goal="5" amount="1000">Small</x-HelloWorld> </p>
</div>
'></mws-Demo></li>
-->

